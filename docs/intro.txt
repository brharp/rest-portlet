REST Portlet
============

## Introduction

REST Portlet is a technology-neutral adaptation of the Java Portlet
API. It is a protocol extension of HTTP that allows portlets to be
written in any programming language that can read and write HTTP
headers.

These pages describe the [protocol specification](spec.html) as well
as an implementation of the protocol as a JSR-168 portlet.

Please direct any questions or comments to <brharp@uoguelph.ca>.

## Overview

REST Portlet is a direct mapping of the Java Portlet API to features
of HTTP. The portal communicates with a REST portlet through a series
of HTTP requests. The REST portlet can get information about its state
by reading extended HTTP headers, and may modify its state by writing
HTTP headers.

                X-Portlet-Method: view
                X-Portlet-Mode: normal
                X-Portlet-State: edit
                  .
                  .
                  .
    +--------+               +---------+
    |        | ------------> |         |
    | Portal |      HTTP     | Portlet |
    |        | <------------ |         |
    +--------+               +---------+
                         .
                         .
                         .
                X-Portlet-Set-Mode: view
                X-Portlet-Set-Preference: colour=red


This arrangement allows any program that can read and write HTTP
headers to implement a full featured portlet.

## Getting Started

The only requirement for implementing a REST portlet is responding to
an HTTP GET request. In fact, a static HTML page is a valid (albeit
boring) REST portlet. Given that, the "Hello, World" of REST portlets
is the following.

    hello.html

    <p>Hello, World!</p>

However, as we mentioned, that is not a very interesting example. To
do more, we will need to replace our static HTML with dynamically
generated content. To keep things simple, let's consider the following
shell CGI program.

    hello.cgi

    #!/bin/sh
    cat <<HTML
    Content-type: text/html
    
    <P>Hello, ${HTTP_X_PORTLET_REMOTE_USER}</P>
    HTML

Which produces the following output.

    Hello, brharp

Still not too exciting, but as you can see we have customized the
output based on an HTTP header, in this case `X-Portlet-Remote-User`.

This simple interaction demonstrates the underlying principle of REST
portlets---reading HTTP headers and generating a dynamic response.


## More Headers - Portlet Mode and Window State

Unlike standard web applications, portlets may be in one of several
*modes*. For example, a portlet may provide an "edit" mode that allows
for user customization, typically by filling out and submitting a form. A
REST portlet may determine the current mode by inspecting the value of
`X-Portlet-Portlet-Mode` request header. The value will be one of:

 * view
 * edit
 * help

or a custom mode defined in the portlet deployment file.

Portlets are rendered inside of a portlet window which, like in desktop
windowing environments can be minimized or maximized. A REST portlet may
choose to alter its layout when maximized to take advantage of the full
browser window, or it might not render anything at all when minimized
(except perhaps to set the window title.) A REST portlet can determine the
current window state by examining the value of the `X-Portlet-Window-State` 
header. The window state will be one of:

 * normal
 * maximized
 * minimized

or a custom mode supported by the portal.


## Portlet Preferences

Portlet preferences are a simple key-value database stored between 
portal sessions. Each portlet sees a unique map of preference values.
Although not a replacement for a general purpose database, preferences
are a convenient place to store configuration data in the portal.

Preferences are set from a REST portlet by sending the 
`X-Portlet-Set-Preference` reply  header back to the portal in 
response to a `processAction` request. The preference headers are
"cookie encoded": that is, like HTTP cookies, preferences are encoded as a 
series of 

    key=value

pairs, separated by semi-colons (;). Previously set preferences are 
passed to the REST portlet by the portal for each portlet request,
in the familiar

    key1=value1; key2=value2;

format. For example, to set preferences for foreground and background
colours, we would send the following header to the portal in response
to a `processAction` request:

    X-Portlet-Set-Preference: background=black; foreground=white

and the portal would return the following header with each portlet request:

    X-Portlet-Preference: background=black; foreground=white


## Portlet URLs

Self referential URLs must be generated by the portlet container. The
portlet API provides methods to generate self referential URLs that 
trigger a refresh of the portlet window, change the portlet mode or 
window state, or set additional request parameters.

Portlet URLs may be generated from REST portlets by emitting URLs
in the special "portlet:" scheme. Portlet scheme URLs are translated
by the portlet stub running in the portlet container, which has 
access to the full portlet API for generating URLs expected by the 
portlet container.

The general format of a "portlet:" scheme URL is:

portlet:(render|processAction)[;mode=(view|edit|help|...)]
	[;state=(normal|maximized|minimized|...)]
	[;secure=(true|false)]
	[?(name=value)*]

Some examples of portlet URLs are:

A render URL -

	<a href="portlet:render">refresh</a>

A render URL with parameters -

	<a href="portlet:render?show=all">Expand</a>

A render URL that maximizes the window -

	<a href="portlet:render;state=maximized">Maximize</a>

A form submission that returns the user to "view" mode -

	<form action="portlet:processAction;mode=view" method="post">
		<input name="foo"></input>
		<input type="submit"/>
	</form>



## Render Parameters

Portal pages have an action phase and a render phase: the action 
phase targets a single portlet, while the render phase includes
every portlet on the page. A render request can come in isolation,
but a process action request is always followed by a render request.

Since the process action request can not generate any output, it's
common to pass data forward from the process action phase to the 
render phase as *render parameters*, instead of cluttering the 
session or preference name spaces with temporary variables. Render 
parameters are set in response to a `processAction` request,
and live only as long as the next `render` request.

To set a render parameter, send the `X-Portlet-Set-Render-Parameter`. 
Render parameters are passed to the REST portlet in the 
query string a a `render` request.


## User Info

One feature of a portal is access to user information, such as
attributes commonly found in a directory. Portals expose selected
user information to portlets via the user info map. REST portlets
have access to the user info map via the `X-Portlet-User-Info`
request header. Like preferences, the user info header is 
"cookie encoded" key=value pairs, separated by a semi-colon and
a space. The user info header is sent with all portlet requests.


## Portlet Namespace

Portlets share the page and must be careful to give unique 
identifiers to DOM elements. The portlet provides a unique
namespace to each portlet instance, which is passed to REST
portlets via the `X-Portlet-Namespace` request header. Portlets
that generate HTML elements with an ID attribute or JavaScript
functions and variables must take care to prefix these identifiers
with the portlet namespace value.


## Conclusion

REST portlet provides a simple protocol for programs deployed 
beyond the portal server, and written not necessarily in Java,
to participate in the portal framework. As much of the portlet
API as possible is exposed to REST portlets in HTTP request
and response headers, allowing for tight portal integration.
